// Generated by CoffeeScript 1.8.0
var Snake,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Snake = (function(_super) {
  __extends(Snake, _super);

  Snake.prototype.head_color = "#e77";

  Snake.prototype.color = "#ccc";

  Snake.prototype.UP = 1;

  Snake.prototype.RIGHT = 2;

  Snake.prototype.DOWN = 3;

  Snake.prototype.LEFT = 4;

  function Snake(game) {
    var x, y;
    this.game = game;
    x = Math.floor(this.game.width / 2);
    y = Math.floor(this.game.height / 2);
    this.points = [[x, y - 1], [x, y], [x, y + 1]];
    this.tail = [x - 1, y + 1];
    this.direction = this.RIGHT;
    this.draw();
  }

  Snake.prototype.move = function() {
    var first, free, free_points, next, next_is_free, _i, _len;
    first = this.points[0];
    switch (this.direction) {
      case this.UP:
        if (first[1] > 0) {
          next = [first[0], first[1] - 1];
        } else {
          next = [first[0], this.game.height - 1];
        }
        break;
      case this.RIGHT:
        if (first[0] < this.game.width - 1) {
          next = [first[0] + 1, first[1]];
        } else {
          next = [0, first[1]];
        }
        break;
      case this.DOWN:
        if (first[1] < this.game.height - 1) {
          next = [first[0], first[1] + 1];
        } else {
          next = [first[0], 0];
        }
        break;
      case this.LEFT:
        if (first[0] > 0) {
          next = [first[0] - 1, first[1]];
        } else {
          next = [this.game.width - 1, first[1]];
        }
    }
    free_points = intersec_arrays(this.game.map.points, this.points, arr_comp);
    for (_i = 0, _len = free_points.length; _i < _len; _i++) {
      free = free_points[_i];
      if (next[0] === free[0] && next[1] === free[1]) {
        next_is_free = true;
      }
    }
    if (next_is_free && next[0] === this.game.food.points[0][0] && next[1] === this.game.food.points[0][1]) {
      this.points.unshift(next);
      this.game.food.respawn();
      this.game.score.next();
    } else if (next_is_free) {
      this.tail = this.points.pop();
      this.points.unshift(next);
    } else {
      this.game.over = true;
    }
  };

  Snake.prototype.turn_left = function() {
    if (this.direction > 1) {
      return this.direction--;
    } else {
      return this.direction = this.LEFT;
    }
  };

  Snake.prototype.turn_right = function() {
    if (this.direction < 4) {
      return this.direction++;
    } else {
      return this.direction = this.UP;
    }
  };

  Snake.prototype.draw = function() {
    Snake.__super__.draw.call(this, [this.tail], this.game.map.color);
    Snake.__super__.draw.apply(this, arguments);
    return Snake.__super__.draw.call(this, [this.points[0]], this.head_color);
  };

  return Snake;

})(GameObject);
